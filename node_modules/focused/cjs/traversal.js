"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.eachMapKey = exports.eachMapValue = undefined;
exports.each = each;
exports.eachOf = eachOf;
exports.filtered = filtered;
exports.maybeProp = maybeProp;

var _utils = require("./utils");

var _operations = require("./operations");

var _iso = require("./iso");

var _lens = require("./lens");

/*
    type Traversal<S,T,A,B> = (Applicative<F>, A => F<B>, S) => F<T>
    type SimpleTraversal<S,A> = Traversal<S,S,A,A>
*/

// each : Traversal< Array<A>, Array<B>, A, B>
function each(anApplicative, f, xs) {
  return anApplicative.combine(_utils.id, xs.map(f));
}

// eachOf: <A>() => Traversal< Array<A>, Array<B>, A, B>
// this of the convenience of typings since TypeScript doesn't
// allow type parameters on non functions
function eachOf() {
  return each;
}

// filter : (A => Boolean) => Traversal< Array<A>, Array<B>, A, B>
function filtered(pred, traverse = each) {
  return function filterTraversal(anApplicative, f, s) {
    return traverse(anApplicative, update, s);

    function update(v) {
      return pred(v) ? f(v) : anApplicative.pure(v);
    }
  };
}

// maybeProp :: K => SimpleTraversal<S, S[K]>
// This is an Affine Traversal; ie focus on 0 or 1 value
function maybeProp(name) {
  return function propTraversal(anApplicative, f, s) {
    if (!s.hasOwnProperty(name)) {
      return anApplicative.pure(s);
    }
    return anApplicative.map(a2 => {
      return Object.assign({}, s, {
        [name]: a2
      });
    }, f(s[name]));
  };
}

// eachValue :: SimpleTraversal<Map<K,V>, V>
const eachMapValue = exports.eachMapValue = (0, _operations.compose)(_iso.mapEntries, each, (0, _lens.index)(1));

// eachKey :: SimpleTraversal<Map<K,V>, K>
const eachMapKey = exports.eachMapKey = (0, _operations.compose)(_iso.mapEntries, each, (0, _lens.index)(0));